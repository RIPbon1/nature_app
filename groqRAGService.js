import Groq from 'groq-sdk';
import knowledgeService from './knowledgeService.js';

class GroqRAGService {
  constructor() {
    this.groq = new Groq({
      apiKey: process.env.GROQ_API_KEY || 'your-groq-api-key-here'
    });
    this.weatherApiKey = process.env.OPENWEATHER_API_KEY || 'your-openweather-api-key-here';
    this.systemPrompt = `You are AirAware, a friendly and knowledgeable weather expert! You're here to help people understand weather, climate, and air quality in a clear, helpful way.
    CRITICAL LANGUAGE INSTRUCTIONS:
    1. ALWAYS detect the language of the user's question
    2. ALWAYS respond in the EXACT SAME LANGUAGE as the user's question
    3. If user asks in Hindi (‡§π‡§ø‡§Ç‡§¶‡•Ä), respond ONLY in Hindi
    4. If user asks in English, respond ONLY in English
    5. If user asks in Marathi (‡§Æ‡§∞‡§æ‡§†‡•Ä), respond ONLY in Marathi
    6. If user asks in Gujarati (‡™ó‡´Å‡™ú‡™∞‡™æ‡™ü‡´Ä), respond ONLY in Gujarati
    7. If user asks in Spanish, respond ONLY in Spanish
    8. If user asks in Arabic (ÿßŸÑÿπÿ±ÿ®Ÿäÿ©), respond ONLY in Arabic
    CONTENT INSTRUCTIONS:
    1. Be short, clear, and conversational ‚Äî like texting a friend.
    2. Never overload with info. Keep responses easy to skim.
    3. Always give a one-line "at a glance" summary first.
    4. Use at most 3 bullet points per section.
    5. Only include sections that are relevant:
      - Normal pleasant weather: Key Points + Pro Tip
      - Bad/extreme weather: Key Points + Important Notes (+ Pro Tip if needed)
    6. Always provide practical, actionable advice for weather-related decisions.
    7. Use emojis for warmth, but don't overdo them (max 1‚Äì2 per line).
    8. Break text into short chunks with lots of spacing, this is VERY important.
    RESPONSE FORMAT:
    Use this friendly, spaced-out structure:
    üå§Ô∏è **Today's Weather**
    Quick one-liner summary (temperature + condition + vibe).
    **üîç Key Points:**
    ‚Ä¢ Simple fact about sky (sunny / cloudy / rainy)  
    ‚Ä¢ Temperature & humidity  
    ‚Ä¢ Wind or rain chance if relevant  
    **üí° Pro Tip:**
    ‚Ä¢ One short tip for outdoor plans OR health  
    **‚ö†Ô∏è Note (only if needed):**
    ‚Ä¢ Quick safety reminder (umbrella, sunscreen, hydration, storm prep, etc.)
    FORMATTING RULES:
    - Always leave 2‚Äì3 blank lines between major sections.
    - Always leave 1 blank line after colons before bullets.
    - Keep answers short ‚Äî max 6‚Äì7 lines total.
    - Do NOT write long paragraphs.
    - Make each section visually distinct with spacing.
    Always be helpful, friendly, and supportive. Write like a caring local weather buddy.`;

  }

  async generateResponse(question, conversationHistory = [], userLocation = null, userProfile = null) {
    console.log('üå§Ô∏è Groq Weather RAG Service called with question:', question.substring(0, 50) + '...');
    console.log('üîë Groq API Key available:', process.env.GROQ_API_KEY ? 'Yes' : 'No');
    
    // Check if question is weather-related
    if (!this.isWeatherRelated(question)) {
      const response = `üå§Ô∏è
**Hey there! I'm AirAware!** üòä

I'm your friendly weather expert, here to chat about all things weather!

**What I can help with:**
‚Ä¢ Weather safety and preparation  
‚Ä¢ Air quality information  
‚Ä¢ Climate patterns and changes  
‚Ä¢ Storm and extreme weather advice  
‚Ä¢ Seasonal weather guidance  

I only discuss weather-related topics, but I'm happy to help with any weather questions you have!`;
      return this.formatResponse(response);
    }
    
    let relevantKnowledge;
    try {
      console.log('üîç Searching weather knowledge base...');
      relevantKnowledge = await knowledgeService.searchSimilar(question, 3);
      let contextPrompt = this.systemPrompt + '\n\n';
      
      if (relevantKnowledge && relevantKnowledge.length > 0) {
        contextPrompt += 'RELEVANT WEATHER KNOWLEDGE FROM DATABASE:\n';
        relevantKnowledge.forEach((knowledge, index) => {
          contextPrompt += `\n${index + 1}. ${knowledge.title}\n`;
          contextPrompt += `${knowledge.content}\n`;
          contextPrompt += `Category: ${knowledge.category}\n`;
          contextPrompt += `Similarity Score: ${knowledge.similarity.toFixed(3)}\n`;
        });
        contextPrompt += '\nUse this knowledge to provide accurate and specific weather advice.\n\n';
      }
      
      if (userProfile) {
        const profileContext = this.getUserProfileContext(userProfile);
        if (profileContext) {
          contextPrompt += `USER PROFILE AND LOCATION INFORMATION:\n${profileContext}\n\n`;
        }
      }
      
      if (userLocation) {
        // Get real weather data
        const realWeatherData = await this.getRealWeatherData(userLocation);
        if (realWeatherData) {
          contextPrompt += `CURRENT REAL-TIME WEATHER DATA:\n`;
          contextPrompt += `Location: ${realWeatherData.location}\n`;
          contextPrompt += `Temperature: ${realWeatherData.temperature}¬∞C (${realWeatherData.temperatureF}¬∞F)\n`;
          contextPrompt += `Condition: ${realWeatherData.condition}\n`;
          contextPrompt += `Humidity: ${realWeatherData.humidity}%\n`;
          contextPrompt += `Wind Speed: ${realWeatherData.windSpeed} m/s\n`;
          contextPrompt += `Wind Direction: ${realWeatherData.windDirection}\n`;
          contextPrompt += `Pressure: ${realWeatherData.pressure} hPa\n`;
          contextPrompt += `Visibility: ${realWeatherData.visibility} km\n`;
          contextPrompt += `UV Index: ${realWeatherData.uvIndex}\n`;
          contextPrompt += `Sunrise: ${realWeatherData.sunrise}\n`;
          contextPrompt += `Sunset: ${realWeatherData.sunset}\n`;
          contextPrompt += `Feels Like: ${realWeatherData.feelsLike}¬∞C (${realWeatherData.feelsLikeF}¬∞F)\n\n`;
          contextPrompt += `IMPORTANT: Use this real-time weather data to provide accurate, location-specific weather advice and forecasts.\n\n`;
        }
        
        // Also add the basic location context
        const weatherContext = await this.getWeatherContext(userLocation);
        if (weatherContext) {
          contextPrompt += `LOCATION CONTEXT:\n${weatherContext}\n\n`;
        }
      }
      
      if (conversationHistory && conversationHistory.length > 0) {
        const recentHistory = conversationHistory.slice(-4); 
        contextPrompt += 'CONVERSATION HISTORY:\n';
        recentHistory.forEach(msg => {
          contextPrompt += `${msg.isUser ? 'Human' : 'Assistant'}: ${msg.content}\n`;
        });
        contextPrompt += '\n';
      }
      
      const detectedLanguage = this.detectLanguage(question);
      const languageInstruction = this.getLanguageInstruction(detectedLanguage);
      console.log('üì° Calling Groq API...');
      console.log('üåç Detected language:', detectedLanguage);
      
      const completion = await this.groq.chat.completions.create({
        messages: [
          {
            role: 'system',
            content: contextPrompt + '\n\n' + languageInstruction
          },
          {
            role: 'user',
            content: question
          }
        ],
        model: 'llama3-8b-8192', 
        temperature: 0.7,
        max_tokens: 1200,
        top_p: 0.9,
        stream: false
      });
      
      console.log('‚úÖ Groq API response received');
      const response = completion.choices[0]?.message?.content || 'Sorry, I could not generate a weather response.';
      return this.formatResponse(response);
    } catch (error) {
      console.error('‚ùå Groq Weather RAG Service Error:', error);
      if (error.status === 429 || error.message?.includes('rate limit')) {
        return this.formatResponse("üö¶\n**Rate Limit Notice**\n\nGroq API rate limit reached. Please wait a moment and try again.\n\n**What you can do:**\n‚Ä¢ Wait 1-2 minutes and retry\n‚Ä¢ Try asking a simpler weather question\n‚Ä¢ The service should return to normal shortly");
      } else if (error.status === 401 || error.message?.includes('API key')) {
        return this.formatResponse("üîë\n**API Key Issue**\n\nThere's an issue with the Groq API configuration. Please check your API key.");
      } else if (error.status === 503 || error.message?.includes('unavailable')) {
        return this.formatResponse("üîß\n**Service Temporarily Unavailable**\n\nGroq's weather service is temporarily unavailable. Please try again in a few minutes.");
      } else {
        const fallback = await this.getFallbackResponse(question, relevantKnowledge);
        return this.formatResponse(fallback);
      }
    }
  }

  // New method to fetch real weather data from OpenWeatherMap
  async getRealWeatherData(location) {
    try {
      if (!location.lat || !location.lon) {
        console.log('No coordinates available for weather data');
        return null;
      }
      
      console.log('üå°Ô∏è Fetching real weather data for:', location.lat, location.lon);
      
      const response = await fetch(
        `https://api.openweathermap.org/data/2.5/weather?lat=${location.lat}&lon=${location.lon}&appid=${this.weatherApiKey}&units=metric`
      );
      
      if (!response.ok) {
        console.error('Weather API error:', response.status, response.statusText);
        return null;
      }
      
      const data = await response.json();
      
      // Convert wind direction to compass direction
      const windDirection = this.getWindDirection(data.wind?.deg);
      
      // Format sunrise and sunset times
      const sunrise = new Date(data.sys?.sunrise * 1000).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      const sunset = new Date(data.sys?.sunset * 1000).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      
      return {
        location: `${data.name}, ${data.sys?.country}`,
        temperature: Math.round(data.main?.temp),
        temperatureF: Math.round(data.main?.temp * 9/5 + 32),
        condition: data.weather?.[0]?.description || 'Unknown',
        humidity: data.main?.humidity,
        windSpeed: data.wind?.speed,
        windDirection: windDirection,
        pressure: data.main?.pressure,
        visibility: (data.visibility / 1000).toFixed(1),
        uvIndex: 'N/A', // UV index requires a separate API call
        sunrise: sunrise,
        sunset: sunset,
        feelsLike: Math.round(data.main?.feels_like),
        feelsLikeF: Math.round(data.main?.feels_like * 9/5 + 32)
      };
    } catch (error) {
      console.error('Error fetching real weather data:', error);
      return null;
    }
  }
  
  // Helper method to convert wind degrees to compass direction
  getWindDirection(degrees) {
    if (!degrees) return 'Unknown';
    const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
    const index = Math.round((degrees % 360) / 22.5);
    return directions[index % 16];
  }

  async getFallbackResponse(question, relevantKnowledge = null) {
    try {
      if (!relevantKnowledge) {
        relevantKnowledge = await knowledgeService.searchSimilar(question, 2);
      }
      
      if (relevantKnowledge && relevantKnowledge.length > 0) {
        let response = `üå§Ô∏è\n**Based on our weather knowledge base:**\n\n`;
        relevantKnowledge.forEach((knowledge, index) => {
          response += `**${knowledge.title}**\n`;
          response += `${knowledge.content}\n\n`;
        });
        response += `üí°\n**Note:** This response is from our local weather knowledge base. For more personalized weather advice, please try again when the AI service is available.`;
        return this.formatResponse(response);
      } else {
        return this.getBasicFallbackResponse(question);
      }
    } catch (error) {
      console.error('‚ùå Error in weather fallback response:', error);
      return this.getBasicFallbackResponse(question);
    }
  }

  getBasicFallbackResponse(question) {
    const lowerQuestion = question.toLowerCase();
    
    if (lowerQuestion.includes('weather') || lowerQuestion.includes('forecast') || lowerQuestion.includes('temperature')) {
      const response = `üå§Ô∏è\n**Weather Information**

For accurate weather information, consider these key factors:

**üîç Current Conditions:**
‚Ä¢ Check temperature, humidity, and wind speed  

**üìÖ Forecast:**
‚Ä¢ Look at short-term and extended forecasts  

**‚ö†Ô∏è Severe Weather:**
‚Ä¢ Be aware of any weather warnings or alerts  

**üìç Local Variations:**
‚Ä¢ Weather can vary significantly within small areas  

**üå± Seasonal Patterns:**
‚Ä¢ Consider typical weather for the time of year  

**üéØ Preparation:**
‚Ä¢ Plan activities based on expected conditions  

For specific weather advice, please let me know your location and what you're planning!`;
      return this.formatResponse(response);
    }
    
    if (lowerQuestion.includes('air quality') || lowerQuestion.includes('aqi') || lowerQuestion.includes('pollution')) {
      const response = `üå¨Ô∏è\n**Air Quality Guidance**

Air quality affects health and outdoor activities:

**üìä AQI Levels:**
‚Ä¢ 0-50: Good  
‚Ä¢ 51-100: Moderate  
‚Ä¢ 101-150: Unhealthy for Sensitive Groups  

**üè• Health Effects:**
‚Ä¢ Poor air quality can affect breathing and overall health  

**üõ°Ô∏è Precautions:**
‚Ä¢ Limit outdoor activities during poor air quality days  

**üì± Monitoring:**
‚Ä¢ Check local air quality reports regularly  

**üè† Indoor Air:**
‚Ä¢ Use air purifiers and maintain good ventilation  

The key is staying informed and taking appropriate precautions!`;
      return this.formatResponse(response);
    }
    
    if (lowerQuestion.includes('rain') || lowerQuestion.includes('storm') || lowerQuestion.includes('precipitation')) {
      const response = `üåßÔ∏è\n**Precipitation and Storm Safety**

Stay safe during wet weather:

**‚òî Rain Preparation:**
‚Ä¢ Carry umbrellas and wear appropriate footwear  

**‚ö° Storm Safety:**
‚Ä¢ Seek shelter during thunderstorms and severe weather  

**üåä Flooding:**
‚Ä¢ Avoid driving through flooded areas  

**‚ö° Lightning:**
‚Ä¢ Stay indoors during electrical storms  

**üìª Monitoring:**
‚Ä¢ Keep track of weather alerts and warnings  

**üÜò Emergency Kit:**
‚Ä¢ Have essential supplies ready  

Always prioritize safety during severe weather conditions!`;
      return this.formatResponse(response);
    }
    
    const response = `üå§Ô∏è\n**Weather & Climate Helper**

I'm here to help with all your weather questions! I can provide advice on:

**üå°Ô∏è Weather & Forecast:**
‚Ä¢ Current conditions and predictions  
‚Ä¢ Seasonal patterns and changes  

**üå¨Ô∏è Air Quality:**
‚Ä¢ Pollution levels and health impacts  
‚Ä¢ Safety precautions  

**‚ö†Ô∏è Safety & Prep:**
‚Ä¢ Severe weather guidance  
‚Ä¢ Emergency planning tips  

**üè• Health:**
‚Ä¢ Weather-related health advice  
‚Ä¢ Outdoor activity recommendations  

Ask me anything about weather, climate, or air quality!`;
    return this.formatResponse(response);
  }

  getUserProfileContext(userProfile) {
    try {
      let context = '';
      if (userProfile.profile) {
        const profile = userProfile.profile;
        context += `User Profile:\n`;
        if (profile.fullName) context += `- Name: ${profile.fullName}\n`;
        if (profile.location) context += `- Location: ${profile.location}\n`;
        context += '\n';
      }
      if (userProfile.weatherPreferences) {
        const weather = userProfile.weatherPreferences;
        context += `Weather Preferences:\n`;
        if (weather.unit) context += `- Temperature Unit: ${weather.unit}\n`;
        if (weather.activities) context += `- Outdoor Activities: ${weather.activities}\n`;
        if (weather.healthConcerns) context += `- Health Concerns: ${weather.healthConcerns}\n`;
        context += '\n';
      }
      if (context) {
        context += `IMPORTANT: Use this profile and location information to provide personalized weather advice.`;
      }
      return context;
    } catch (error) {
      console.error('Error getting user profile context:', error);
      return null;
    }
  }

  async getWeatherContext(location) {
    try {
      let context = `User Location: ${location.city || 'Unknown'}, ${location.country || 'Unknown'}\n`;
      
      if (location.lat && location.lon) {
        context += `Coordinates: ${location.lat}, ${location.lon}\n`;
      }
      context += `\nIMPORTANT: Use this location information to provide location-specific weather advice.`;
      return context;
    } catch (error) {
      console.error('Error getting weather context:', error);
      return null;
    }
  }

  detectLanguage(text) {
    const hindiPattern = /[\u0900-\u097F]/;
    const marathiPattern = /[\u0900-\u097F]/; 
    const gujaratiPattern = /[\u0A80-\u0AFF]/;
    const arabicPattern = /[\u0600-\u06FF]/;
    const spanishPattern = /[√±√°√©√≠√≥√∫√º]/i;
    
    if (hindiPattern.test(text)) {
      if (text.includes('‡§ï‡•ç‡§Ø‡§æ') || text.includes('‡§ï‡•à‡§∏‡•á') || text.includes('‡§Æ‡•Å‡§ù‡•á') || text.includes('‡§¨‡§§‡§æ‡§è‡§Ç')) {
        return 'hindi';
      }
      if (text.includes('‡§ï‡§æ‡§Ø') || text.includes('‡§ï‡§∏‡•á') || text.includes('‡§Æ‡§≤‡§æ') || text.includes('‡§∏‡§æ‡§Ç‡§ó‡§æ')) {
        return 'marathi';
      }
      return 'hindi'; 
    }
    
    if (gujaratiPattern.test(text)) return 'gujarati';
    if (arabicPattern.test(text)) return 'arabic';
    if (spanishPattern.test(text)) return 'spanish';
    return 'english'; // Default to English
  }

  getLanguageInstruction(language) {
    const instructions = {
      hindi: 'CRITICAL: The user asked in Hindi. You MUST respond ONLY in Hindi (‡§π‡§ø‡§Ç‡§¶‡•Ä). Do not use any English words. Use Hindi weather terminology.',
      marathi: 'CRITICAL: The user asked in Marathi. You MUST respond ONLY in Marathi (‡§Æ‡§∞‡§æ‡§†‡•Ä). Do not use any English words. Use Marathi weather terminology.',
      gujarati: 'CRITICAL: The user asked in Gujarati. You MUST respond ONLY in Gujarati (‡™ó‡´Å‡™ú‡™∞‡™æ‡™ü‡´Ä). Do not use any English words. Use Gujarati weather terminology.',
      arabic: 'CRITICAL: The user asked in Arabic. You MUST respond ONLY in Arabic (ÿßŸÑÿπÿ±ÿ®Ÿäÿ©). Do not use any English words. Use Arabic weather terminology.',
      spanish: 'CRITICAL: The user asked in Spanish. You MUST respond ONLY in Spanish (Espa√±ol). Do not use any English words. Use Spanish weather terminology.',
      english: 'CRITICAL: The user asked in English. You MUST respond ONLY in English. Use clear English weather terminology.'
    };
    return instructions[language] || instructions.english;
  }

  formatResponse(text) {
    let formatted = text;
    // Convert **bold** markdown to <strong>
    formatted = formatted.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    // Ensure bold sections always start on a new line
    formatted = formatted.replace(/(<strong>[^<]+<\/strong>)/g, '\n$1\n');
    // Clean up bullet points
    formatted = formatted.replace(/^[‚Ä¢¬∑]\s*/gm, '‚Ä¢ ');
    formatted = formatted.replace(/([‚Ä¢¬∑])/g, '\n$1');
    // Add spacing after headers/emojis + bold
    formatted = formatted.replace(
      /(üå§Ô∏è|üåßÔ∏è|üå¨Ô∏è|üå°Ô∏è|‚õàÔ∏è|üå™Ô∏è|‚ùÑÔ∏è|‚òÄÔ∏è|üå¶Ô∏è|üå©Ô∏è|üí®|üåà|üåä|üèîÔ∏è|üåç|‚ö°|üîß|üìã|üéØ|üí°|‚ö†Ô∏è|‚úÖ|üöÄ)(\s*<strong>[^<]+<\/strong>)/g,
      '\n\n$1\n$2\n'
    );
    // Fix section headers like "Pro Tips:" or "Important Notes:"
    formatted = formatted.replace(/(Important Notes|Pro Tips|Forecast|Current Weather Conditions|Air Quality|Wind|Precipitation|Temperature):/gi, '\n\n$1:');
    // Avoid huge blank gaps
    formatted = formatted.replace(/\n{5,}/g, '\n\n\n\n');
    formatted = formatted.replace(/^\n+/, '');
    return formatted.trim();
  }

  isWeatherRelated(question) {
    const weatherKeywords = [
      'weather', 'climate', 'temperature', 'rain', 'snow', 'storm', 'thunder', 'lightning',
      'wind', 'humidity', 'air quality', 'aqi', 'forecast', 'sunny', 'cloudy', 'fog',
      'hurricane', 'tornado', 'blizzard', 'flood', 'drought', 'heat', 'cold', 'freeze',
      'frost', 'hail', 'sleet', 'mist', 'dew', 'pressure', 'barometer', 'thermometer',
      'season', 'spring', 'summer', 'fall', 'autumn', 'winter', 'monsoon', 'typhoon',
      'cyclone', 'tsunami', 'earthquake', 'volcano', 'smog', 'pollution', 'ozone',
      'uv', 'ultraviolet', 'sunburn', 'heatstroke', 'hypothermia', 'frostbite',
      'meteorology', 'atmosphere', 'precipitation', 'evaporation', 'condensation',
      'weatherman', 'meteorologist', 'weather station', 'radar', 'satellite'
    ];
    const questionLower = question.toLowerCase();
    return weatherKeywords.some(keyword => questionLower.includes(keyword));
  }
}

export default new GroqRAGService();